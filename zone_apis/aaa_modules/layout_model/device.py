from copy import copy
import time

from aaa_modules import platform_encapsulator as pe


class Device(object):
    """
    The base class that all other sensors and switches derive from.
    """

    def __init__(self, openhab_item, battery_powered=False, wifi=False,
                 auto_report=False):
        """
        Ctor

        :param Item openhab_item:
        :param bool battery_powered: indicates if the device is powered by battery.
        :param bool wifi: indicates if the device communicates by WiFi.
        :param bool auto_report: indicates if the device periodically reports
                its value.
        :raise ValueError: if any parameter is invalid
        """
        if openhab_item is None:
            raise ValueError('openhabItem must not be None')

        self.item = openhab_item
        self.batteryPowered = battery_powered
        self.wifi = wifi
        self.autoReport = auto_report
        self.last_activated_timestamp = None
        self.zoneManager = None
        self.channel = None

    def contains_item(self, item):
        """
        Returns true if this device contains the specified item.
        Subclass needs to override if it contains more than one item.
        """
        return pe.get_item_name(self.item) == pe.get_item_name(item)

    def get_item(self):
        """
        Returns the backed OpenHab item.

        :rtype: Item
        """
        return self.item

    def get_item_name(self):
        """
        Returns the backed OpenHab item name.

        :rtype: str
        """
        return pe.get_item_name(self.item)

    def set_channel(self, channel: str):
        """
        Set the OpenHab channel string (configured in the item metadata).

        :return: A NEW object with the additional newly set channel.
        """
        new_obj = copy(self)
        new_obj.channel = channel

        return new_obj

    def get_channel(self) -> str:
        """
        Returns the OpenHab channel string linked with the item.

        :rtype: str the channel string or None if the item is not linked to a channel
        """
        return self.channel

    def set_battery_powered(self, bool_value):
        """
        :return: A NEW object with the batteryPowered attribute set to the
                specified value
        """
        new_obj = copy(self)
        new_obj.batteryPowered = bool_value

        return new_obj

    def is_battery_powered(self):
        """
        Returns True if the device is powered by a batter; False otherwise.

        :rtype: Boolean
        """

        return self.batteryPowered

    def set_use_wifi(self, bool_value):
        """
        :return: A NEW object with the wifi attribute set to the specified value
        """
        new_obj = copy(self)
        new_obj.wifi = bool_value

        return new_obj

    def use_wifi(self):
        """
        Returns True if the device communicates using WiFi.

        :rtype: Boolean
        """
        return self.wifi

    def set_auto_report(self, bool_value):
        """
        :return: A NEW object with the autoReport attribute set to the specified value.
        """
        new_obj = copy(self)
        new_obj.autoReport = bool_value

        return new_obj

    def is_auto_report(self):
        """
        Returns True if the device periodically sends its value.

        :rtype: Boolean
        """
        return self.autoReport

    def set_zone_manager(self, zone_manager):
        """
        :return: A NEW object with the zoneManager attribute set to the
            specified value.
        """
        new_obj = copy(self)
        new_obj.zoneManager = zone_manager

        return new_obj

    def get_zone_manager(self):
        """
        Returns the zone the device belong to or None if the device does not
        belong to any zone.

        :rtype: Zone
        """
        return self.zoneManager

    def is_occupied(self, seconds_from_last_event=5 * 60):
        """
        Returns boolean indicating if the present state of the device might
        indicate that the zone is occupied.

        :rtype: bool
        """
        return False

    def get_last_activated_timestamp(self):
        """
        Returns the timestamp in epoch seconds of the last event generated by
        the device.

        :rtype: int the last activated epoch second or None if not no event has
            been generated.
        """
        return self.last_activated_timestamp

    def reset_value_states(self):
        """
        Reset the underlying OpenHab item state.

        This method can be used when the physical device mal-functions and
        no longer sends the value update. A watch dog process can determine
        that the device is offline and invoke this method to reset the states.

        Devices that have more than one underlying OpenHab values must override
        this method.
        """
        pass

    def was_recently_activated(self, seconds) -> bool:
        """
        :param int seconds: the past duration (from the current time) to
            determine if the device was activated.
        :rtype: bool True if the device was activated during the specified
            seconds; False otherwise.
        """
        prev_timestamp = self.get_last_activated_timestamp()
        if prev_timestamp is None:
            return False
        else:
            return (time.time() - prev_timestamp) <= seconds

    def _update_last_activated_timestamp(self):
        """
        Set the lastActivatedTimestamp field to the current epoch second.
        """
        self.last_activated_timestamp = time.time()

    def __str__(self):
        value = u"{}: {}".format(self.__class__.__name__, self.get_item_name())

        if self.is_battery_powered():
            value += ", battery powered"

        if self.use_wifi():
            value += ", wifi"

        if self.is_auto_report():
            value += ", auto report"

        if self.last_activated_timestamp is not None:
            value += ", last activated: {}".format(self.last_activated_timestamp)

        return value
